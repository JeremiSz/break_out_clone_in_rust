pub use crossterm::{
    event::{self, Event, KeyCode, KeyEvent}
};

use std::cmp;
use std::sync::mpsc;

use crate::GameState;

pub fn start(notifier:mpsc::Sender<usize>){
    loop{
        input(notifier);
    }
    
}


fn input(game_ref : Arc<Mutex<&mut GameState>>){
    let event = event::read().unwrap();

    match event {
        Event::Key(event) => {handle_key(event, game_ref)}
        _ => {}
    }
}
fn handle_key(event:KeyEvent,game_ref : Arc<Mutex<&mut GameState>>){
    let keycode = event.code;
    let mut game_state = game_ref.de get_mut().unwrap();
    

    match keycode{
        KeyCode::Right => {move_right(game_state)},
        KeyCode::Left => {move_left(game_state)},
        KeyCode::Char('c') => {close_game(game_state)},
        _ => {}
    }
    
}
fn move_right(game_state:&mut GameState){
    let current_pos = game_state.paddle_pos;
    (*game_state).paddle_pos = cmp::min(super::COL-game_state.paddle_size,current_pos + 1);
}
fn move_left(game_state : &mut GameState){
    let current_pos = game_state.paddle_pos;
    game_state.paddle_pos = cmp::max(0,current_pos - 1);
}
fn close_game(game_state : &mut GameState){
    game_state.game_ended = true;
}